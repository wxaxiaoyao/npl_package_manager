
NPL.load("common.npl")

-- 实现方式一  递归加载
--function load_pacakge(package_args)
	--local package = g_packages:get(package_args)	

	--if not package then
		--log.warn("未安装包:" .. package_args.name .. " 版本:" .. (package_args.version or "nil"))
		--return 
	--end

	--load_pacakges(package_dir .. "package.npl")

	--log.info("成功加载依赖包:" .. package.name .. " 版本:" .. package.version)
	--NPL.load(package.install_dir)
--end

--function load_dependencies(package_config) 
	--local dependencies = package_config.dependencies or {}

	--local package_args = {}
	--for key, value in pairs(dependencies or {}) do
		--package_args.name = key
		--if type(dep) == "table" then
			--package_args.package_src = dep.package_src
			--package_args.download_url = dep.download_url
			--package_args.version = dep.version
		--else 
			--package_args.version = dep
		--end
		
		--load_pacakge(package_args)
	--end
--end

---- 加载依赖包
--function load_pacakges(package_config_filename)
	--local file = io.open(package_config_filename, "r")
	--if not file then
		--log.warn("打开包配置文件失败:" .. package_config_filename)
		--return
	--end

	--local package_config_content = file:read("*a")
	--file:close()

	--local package_config = NPL.LoadTableFromString(package_config_content)
	--if not package_config then
		--log.warn("包配置文件格式错误", package_config_content)
		--return
	--end

	--load_dependencies(package_config)
--end

--  实现方式二 递归获取数据 顺序加载


function run(ctx)
	local package_config_filename = ctx.path .. "/package.npl"
	if not file_is_exist(package_config_filename) then
		log.info("不存在包配置文件，不加载依赖包")
		return
	end

	local list = get_package_list_by_filename(package_config_filename)
	log(list)
end


return run
